#include <iostream>
#include <algorithm>
using namespace std;
/*
dp[n] = 포도주 n개가 주어졌을 때, 가장 많이 마실 수 있는 양

p[n] = n번째 포도주의 양


0번 연속 마실 수 있는 경우

n번째 포도주를 0번 마실 경우 n-1의 포도주는 마셔도 되고 안 마셔도 되고 그러니까 그냥 dp[n-1]의 값이 n번째 포도주를 0번 연속 마셨을 경우랑 같습니다.

dp[n] = dp[n-1]



1번 연속 마실 수 있는 경우

n번째 포도주를 1번 연속 마실 수 있는 경우가 되기 위해선 n-1 번째 포도주는 마시면 안됩니다. 마시면 n번째 포도주는 2번 연속 마시게 되는 경우가 되니까요. 그래서 n-1 번째 있는 포도주는 마시면 안됩니다. 그 다음 n-2 번째 있는 포도주는 마셔도 될까요? 안마셔도 될까요? 네 맞습니다. 상관없어요 이미 n-1번째 포도주를 안 마신 것으로도 n번째 포도주가 1번 연속 마실 수 있는 경우를 만족하니까요. 그렇다면 다음 과 같은 식이 완성됩니다.ㅎㅎ

dp[n] = dp[n-2]+p[n]



2번 연속 마실 수 있는 경우

자 마지막으로 n번 포도주가 2번 연속으로 마셨을 경우입니다. 당연히 2번 연속이니까, n-1 포도주는 마셔야 합니다. 자 그다음 n-2번째는 마셔야 할까요? 안 마셔야 할까요? 네 맞습니다. 안마셔야겠죠. n번째 포도주가 2번 연속으로 마셨을 경우가 충족 돼야 하기 때문이죠 ㅎㅎ 그 다음 n-3번째 포도주는 마셔야 할까요? 안 마셔야 할까요? 네 상관없습니다. 그렇다면 다음과 같은 점화식이 완성됩니다!

dp[n]  = dp[n-3]+p[n-1]+p[n]
*/


int n;
int arr[10010];
int dp[10010];

int main() {

	cin >> n;

	for (int i = 1; i <= n; i++)
		cin >> arr[i];


	dp[1] = arr[1];
	dp[2] = dp[1] + arr[2];


	for (int i = 3; i <= n; i++) {
		dp[i] = max(dp[i - 3] + arr[i - 1] + arr[i], max(dp[i - 1], dp[i - 2] + arr[i]));
	}

	//for (int i = 1; i <= n; i++) cout << dp[i] << " ";
	cout << dp[n] << endl;
	return 0;
}